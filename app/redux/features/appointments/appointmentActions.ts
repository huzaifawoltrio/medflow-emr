import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import api from "../../../../lib/axiosConfig";

// Interface for the raw appointment data from the API
export interface Appointment {
  id: number;
  appointment_datetime: string;
  duration: number;
  services: string[];
  status: string;
  patient_id: number;
  doctor_id: number;
  appointment_fee: number;
  billing_type: string;
  location: string;
  repeat: boolean;
}

// Interface for creating a new appointment (omitting fields generated by the backend)
export type NewAppointmentData = Omit<
  Appointment,
  "id" | "doctor_id" | "status"
>;

// Interface for the parameters to fetch appointments (start and end dates)
interface FetchAppointmentsParams {
  startDate: string;
  endDate: string;
}

// Interface for daily appointments response
export interface DailyAppointmentsResponse {
  date: string;
  doctor_id: number;
  doctor_name: string;
  total_appointments: number;
  appointments: DailyAppointment[];
}

// Interface for individual daily appointment
export interface DailyAppointment {
  id: number;
  patient_id: number;
  patient_name: string;
  appointment_datetime: string;
  duration: number;
  location: string;
  services: string[];
  appointment_fee: number;
  billing_type: string;
  status: string;
  created_at: string;
}

// Interface for date range appointments response
export interface DateRangeAppointmentsResponse {
  start_date: string;
  end_date: string;
  doctor_id: number;
  doctor_name: string;
  total_appointments: number;
  appointments_by_date: Record<string, DailyAppointment[]>;
}

/**
 * Async thunk for fetching appointments within a date range.
 * It returns an array of appointments on success.
 */
export const fetchAppointments = createAsyncThunk<
  Appointment[],
  FetchAppointmentsParams,
  { rejectValue: string }
>(
  "appointments/fetchAll",
  async ({ startDate, endDate }, { rejectWithValue }) => {
    try {
      const response = await api.get("/appointments", {
        params: { start: startDate, end: endDate },
      });
      return response.data.appointments || [];
    } catch (error: any) {
      if (error.response && error.response.data.message) {
        return rejectWithValue(error.response.data.message);
      } else {
        return rejectWithValue(error.message || "Failed to fetch appointments");
      }
    }
  }
);

/**
 * Async thunk for creating a new appointment.
 * It takes the appointment data and returns the newly created appointment on success.
 */
export const createAppointment = createAsyncThunk<
  Appointment,
  NewAppointmentData,
  { rejectValue: string }
>("appointments/create", async (appointmentData, { rejectWithValue }) => {
  try {
    const response = await api.post("/appointments", appointmentData);
    return response.data.appointment;
  } catch (error: any) {
    if (error.response && error.response.data.message) {
      return rejectWithValue(error.response.data.message);
    } else {
      return rejectWithValue(error.message || "Failed to create appointment");
    }
  }
});

/**
 * Async thunk for deleting an appointment.
 * It takes the appointment ID and returns the ID on success to be removed from the state.
 */
export const deleteAppointment = createAsyncThunk<
  number, // This is the type of the returned payload on success (appointment ID)
  number, // This is the type of the argument passed to the thunk (appointment ID)
  { rejectValue: string }
>("appointments/delete", async (appointmentId, { rejectWithValue }) => {
  try {
    // Make the DELETE request to the API endpoint
    await api.delete(`/appointments/${appointmentId}`);
    // On success, return the ID of the deleted appointment
    return appointmentId;
  } catch (error: any) {
    if (error.response && error.response.data.message) {
      return rejectWithValue(error.response.data.message);
    } else {
      return rejectWithValue(error.message || "Failed to delete appointment");
    }
  }
});

/**
 * Async thunk for fetching appointments for a specific date.
 */
export const fetchDailyAppointments = createAsyncThunk<
  DailyAppointmentsResponse,
  string, // date parameter (YYYY-MM-DD)
  { rejectValue: string }
>("appointments/fetchDaily", async (date, { rejectWithValue }) => {
  try {
    const response = await api.get("/appointments/daily", {
      params: { date },
    });
    return response.data;
  } catch (error: any) {
    if (error.response?.data?.error) {
      return rejectWithValue(error.response.data.error);
    }
    return rejectWithValue(
      error.message || "Failed to fetch daily appointments"
    );
  }
});

/**
 * Async thunk for fetching today's appointments (convenience function).
 */
export const fetchTodaysAppointments = createAsyncThunk<
  DailyAppointmentsResponse,
  void,
  { rejectValue: string }
>("appointments/fetchTodays", async (_, { rejectWithValue, dispatch }) => {
  const today = new Date().toISOString().split("T")[0];
  try {
    // Reuse the fetchDailyAppointments logic
    const result = await dispatch(fetchDailyAppointments(today));
    if (fetchDailyAppointments.fulfilled.match(result)) {
      return result.payload;
    } else {
      return rejectWithValue(result.payload as string);
    }
  } catch (error: any) {
    return rejectWithValue(
      error.message || "Failed to fetch today's appointments"
    );
  }
});
